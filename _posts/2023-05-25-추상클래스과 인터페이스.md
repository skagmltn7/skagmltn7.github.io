---
title: "추상클래스와 인터페이스"
author: heesu
date: 2023-05-25 22:10:00+0900
categories: [Studying, java]
tags: [추상클래스, 추상메소드, 인터페이스, 다형성]
---

## abstract 
*abstract*은 공통적으로 사용하는 특성을 가진 멤버를 가지고 있고 완성되지 않은 상태이다. `추상메소드`는 선언부만 있고 `추상 클래스`는 추상 메소드가 있고 일반 클래스의 멤버를 가질 수 있다. <br><br>


```java
abstract class A{ // 추상 메소드를 가짐

    abstract void Method1(); 
    abstract void Method2();// 선언부만 있음
}
```


완성되지 않았기 때문에 추상클래스는 `객체를 생성할 수 없다.` 자식 클래스가 추상 클래스를 상속을 받아 추상메소드를 오버라이딩해 완성시킨 후 객체를 생성할 수 있다. `구현을 강제하여 기능을 보장한다.` 또한, 자식 클래스가 메소드에 접근해야하기 때문에 `메소드의 접근 제어자로 private는 사용할 수 없다.` <br><br>

## 인터페이스<br>
 인터페이스는 추상클래스보다 추상화 정도가 높다. 구현된 멤버들이 없기 때문에 객체를 만들 수 없고 `상수와 추상메소드`만 가질 수 있다. (자바1.8이후 default, static메소드도 가질 수 있음.) <br>인터페이스의 상수와 추상메소드의 **기본 제어자**는 다음과 같으며 인터페이스 안에서 생략 가능하다.<br>

 |상수|추상메소드|
 |:---:|:---:|
 public static final|public abstract|


 <br>

### 인터페이스의 상속<br>

 인터페이스는 클래스와 달리 `다중 상속이 가능`하다. 클래스의 경우, 같은 이름의 메소드가 각기 다른 조상클래스에 있으면 어떤 멤버를 선택할지 정하기 어렵기 떄문에 다중상속이 불가능했다. <br><br>
 그러나, 인터페이스는 미완성한 메소드이기 때문에 상속받은 자식클래스에 구현되어 있을 것이고 조상클래스와 메소드이름이 겹쳐도 클래스의 메소드를 사용할 것이기 때문에 다중상속을 허용한다. 인터페이스의 최고조상은 없다.

 
 ```java
 interface B{
    
    int b=1; // public static final생략

    void Method(); // public abstract 생략
 }
 
 ```


 ||클래스|인터페이스|
 |:---:|:---:|:---:|
 |다중상속|X|O|
 |상속방법|extends|implements|

 
 <br>

### 장점<br>

 - **개발시간 단축** <br>

 인터페이스가 없는 경우, 자식클래스는 조상클래스의 구현이 마친 후 구현을 시작할 수 있다. <br>
 그러나 인터페이스가 있는 경우, 인터페이스만 구현해 놓으면 자식 클래스는 선언부만 알면 구현이 가능하다.<br>

 - **표준화 가능**
 - **클래스들 간의 간접관계를 맺어줌**
 - **클래스의 선언과 구현을 분리시키기 때문에 독립적인 프로그래밍이 가능**
 
 <br>

인터페이스는 `선언과 구현을 분리`시킨다. <br>
클래스의 상속(A->B)하면 조상클래스를 다른 클래스로 교체하면 자식클래스의 멤버 중 조상클래스의 멤버를 사용하는 코드를 모두 바꿔야한다. 이를 `직접관계`라 한다.<br>
인터페이스를 사용(A->I->B)하면 B를 다른 클래스로 바꿔도 I의 매개변수 부분만 변경하고 A는 변하지 않는 `간접관계`를 맺을 수 있다.
<br><br>

### +인터페이스에 default,static메소드가 추가된 이유<br>
인터페이스에 새로운 추상 메소드를 추가하면 상속하는 자식클래스들은 모두 메소드를 오버라이딩해야한다.(`구현의 강제성`) 이러한 수고로움을 덜기 위해 인터페이스 내에서 메소드를 구현해 놓으면 각 자식클래스마다 메소드를 구현하지 않아도 되기 때문이다.<br> 